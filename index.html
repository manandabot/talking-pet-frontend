<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="Bring your pets to life! Upload a photo and make your pet talk with AI-powered video generation.">
    <meta name="keywords" content="talking pet, AI video, pet animation, text to speech">
    <meta name="author" content="Talking Pet App">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Talking Pet">
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêæ</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêæ</text></svg>">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;charset=utf-8,{%22name%22:%22Talking%20Pet%20App%22,%22short_name%22:%22TalkingPet%22,%22description%22:%22Make%20your%20pets%20talk%20with%20AI%22,%22start_url%22:%22/%22,%22display%22:%22standalone%22,%22background_color%22:%22%23667eea%22,%22theme_color%22:%22%23667eea%22,%22icons%22:[{%22src%22:%22data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêæ</text></svg>%22,%22sizes%22:%22any%22,%22type%22:%22image/svg+xml%22}]}">
    
    <title>Talking Pet App - Make Your Pet Talk with AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            margin: 0;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 600px;
            width: 100%;
            max-height: 95vh;
            overflow-y: auto;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .container {
                padding: 15px;
                border-radius: 15px;
                max-height: 98vh;
            }
            
            h1 {
                font-size: 2em !important;
                margin-bottom: 20px !important;
            }
            
            .upload-area {
                padding: 20px !important;
            }
            
            .upload-icon {
                font-size: 2em !important;
            }
            
            .controls {
                flex-direction: column !important;
                gap: 10px !important;
            }
            
            button {
                padding: 12px 20px !important;
                font-size: 1em !important;
            }
            
            .api-config {
                grid-template-columns: 1fr !important;
                gap: 10px !important;
            }
            
            .feature-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 10px !important;
            }
            
            .feature {
                padding: 15px !important;
            }
            
            textarea {
                height: 100px !important;
                font-size: 16px !important; /* Prevents zoom on iOS */
            }
        }

        /* Landscape mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .container {
                max-height: 90vh;
            }
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 600px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .upload-section {
            margin-bottom: 30px;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(102, 126, 234, 0.05);
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: rgba(118, 75, 162, 0.1);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: rgba(118, 75, 162, 0.15);
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #667eea;
        }

        .upload-text {
            color: #666;
            font-size: 1.1em;
        }

        input[type="file"] {
            display: none;
        }

        .preview-container {
            margin-top: 20px;
            text-align: center;
        }

        .pet-image {
            max-width: 100%;
            max-height: 300px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease;
        }

        .pet-image:hover {
            transform: scale(1.05);
        }

        .script-section {
            margin-bottom: 30px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: #333;
            font-weight: bold;
            font-size: 1.1em;
        }

        textarea {
            width: 100%;
            height: 120px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1em;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        button {
            flex: 1;
            padding: 15px 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            display: none;
            align-items: center;
            justify-content: center;
            color: #667eea;
            font-weight: bold;
        }

        .loading.active {
            display: flex;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .animation-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .mouth-animation {
            position: absolute;
            width: 30px;
            height: 20px;
            background: #ff6b6b;
            border-radius: 50%;
            opacity: 0;
            transition: all 0.1s ease;
        }

        .mouth-animation.talking {
            opacity: 0.8;
            transform: scaleY(1.5);
        }

        .result-section {
            margin-top: 30px;
            text-align: center;
        }

        .pet-container {
            position: relative;
            display: inline-block;
            margin-bottom: 20px;
        }

        .speech-bubble {
            position: absolute;
            top: -60px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 10px 15px;
            border-radius: 15px;
            border: 2px solid #667eea;
            color: #333;
            font-weight: bold;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 20;
        }

        .speech-bubble:after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-top-color: #667eea;
        }

        .speech-bubble.active {
            opacity: 1;
        }

        .demo-text {
            text-align: center;
            color: #666;
            font-style: italic;
            margin-top: 20px;
        }

        .features {
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #eee;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .feature {
            text-align: center;
            padding: 20px;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 10px;
        }

        .feature-icon {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .feature-text {
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üêæ Talking Pet</h1>
        
        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üì∏</div>
                <div class="upload-text">Click or drag your pet's photo here</div>
                <input type="file" id="fileInput" accept="image/*">
            </div>
            <div class="preview-container" id="previewContainer" style="display: none;">
                <div class="pet-container" id="petContainer">
                    <img id="petImage" class="pet-image" alt="Your pet">
                    <div class="speech-bubble" id="speechBubble"></div>
                    <div class="animation-overlay" id="animationOverlay"></div>
                </div>
            </div>
        </div>

        <div class="script-section">
            <label for="scriptInput">What should your pet say?</label>
            <textarea id="scriptInput" placeholder="Enter your script here... (e.g., 'Hello! I'm a good boy and I love treats!')"></textarea>
        </div>

        <div class="api-config" style="margin-bottom: 20px;">
            <h3 style="color: #333; margin-bottom: 15px;">üîß API Configuration</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div>
                    <label for="apiProvider">Video Provider:</label>
                    <select id="apiProvider" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                        <option value="browser">Browser TTS (Free Demo)</option>
                        <option value="kieai">Kie AI Veo 3 (via Backend)</option>
                        <option value="kieai-direct">Kie AI Veo 3 (Direct - Experimental)</option>
                        <option value="elevenlabs">ElevenLabs TTS</option>
                        <option value="openai">OpenAI TTS</option>
                        <option value="azure">Azure Speech</option>
                    </select>
                </div>
                <div>
                    <label for="apiKey">API Key:</label>
                    <input type="password" id="apiKey" placeholder="Enter API key (optional)" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                </div>
            </div>
        </div>

        <div class="controls">
            <button id="generateBtn">üé¨ Make Pet Talk</button>
            <button id="stopBtn" style="display: none;">‚èπÔ∏è Stop</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            Processing your talking pet...
        </div>

        <div class="demo-text">
            <p>üéØ This is a demo version that simulates the talking pet effect!</p>
            <p>Upload your pet's photo and enter text to see the magic happen.</p>
        </div>

        <div class="features">
            <h3 style="text-align: center; color: #333; margin-bottom: 20px;">‚ú® Features</h3>
            <div class="feature-grid">
                <div class="feature">
                    <div class="feature-icon">üé§</div>
                    <div class="feature-text">Text-to-Speech</div>
                </div>
                <div class="feature">
                    <div class="feature-icon">üé≠</div>
                    <div class="feature-text">Mouth Animation</div>
                </div>
                <div class="feature">
                    <div class="feature-icon">üí¨</div>
                    <div class="feature-text">Speech Bubbles</div>
                </div>
                <div class="feature">
                    <div class="feature-icon">üé®</div>
                    <div class="feature-text">Visual Effects</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentAudio = null;
        let animationInterval = null;
        let speechSynthesis = window.speechSynthesis;
        
        // API Configuration
        const apiProvider = document.getElementById('apiProvider');
        const apiKey = document.getElementById('apiKey');
        
        // API endpoints and configurations
        const API_CONFIGS = {
            elevenlabs: {
                url: 'https://api.elevenlabs.io/v1/text-to-speech',
                headers: (key) => ({
                    'Accept': 'audio/mpeg',
                    'Content-Type': 'application/json',
                    'xi-api-key': key
                })
            },
            openai: {
                url: 'https://api.openai.com/v1/audio/speech',
                headers: (key) => ({
                    'Authorization': `Bearer ${key}`,
                    'Content-Type': 'application/json'
                })
            },
            azure: {
                url: 'https://YOUR_REGION.tts.speech.microsoft.com/cognitiveservices/v1',
                headers: (key) => ({
                    'Ocp-Apim-Subscription-Key': key,
                    'Content-Type': 'application/ssml+xml',
                    'X-Microsoft-OutputFormat': 'audio-16khz-128kbitrate-mono-mp3'
                })
            }
        };

        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const previewContainer = document.getElementById('previewContainer');
        const petImage = document.getElementById('petImage');
        const petContainer = document.getElementById('petContainer');
        const speechBubble = document.getElementById('speechBubble');
        const animationOverlay = document.getElementById('animationOverlay');
        const scriptInput = document.getElementById('scriptInput');
        const generateBtn = document.getElementById('generateBtn');
        const stopBtn = document.getElementById('stopBtn');
        const loading = document.getElementById('loading');

        // Upload area click handler
        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });

        // Drag and drop handlers
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        // File input change handler
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Handle file upload
        function handleFile(file) {
            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    petImage.src = e.target.result;
                    previewContainer.style.display = 'block';
                    setupMouthAnimation();
                };
                reader.readAsDataURL(file);
            } else {
                alert('Please upload an image file.');
            }
        }

        // Setup mouth animation overlay
        function setupMouthAnimation() {
            // Clear existing animations
            animationOverlay.innerHTML = '';
            
            // Create mouth animation element
            const mouthElement = document.createElement('div');
            mouthElement.className = 'mouth-animation';
            
            // Position mouth roughly where it might be on most pets
            mouthElement.style.left = '50%';
            mouthElement.style.top = '70%';
            mouthElement.style.transform = 'translateX(-50%)';
            
            animationOverlay.appendChild(mouthElement);
        }

        // Generate talking pet
        generateBtn.addEventListener('click', () => {
            const script = scriptInput.value.trim();
            if (!script) {
                alert('Please enter a script for your pet to say!');
                return;
            }

            if (!petImage.src) {
                alert('Please upload a pet image first!');
                return;
            }

            generateTalkingPet(script);
        });

        // Stop talking
        stopBtn.addEventListener('click', () => {
            stopTalking();
        });

        async function generateTalkingPet(script) {
            loading.classList.add('active');
            generateBtn.style.display = 'none';
            stopBtn.style.display = 'block';

            // Show speech bubble
            speechBubble.textContent = script;
            speechBubble.classList.add('active');

            const provider = apiProvider.value;
            const key = apiKey.value;

            console.log('üéØ Provider selected:', provider);
            console.log('üîë API key provided:', !!key);

            try {
                if (provider === 'browser') {
                    await generateBrowserTTS(script);
                } else if (key) {
                    // Pass the file input element directly to bypass scope issues
                    await generateApiTTS(script, provider, key, fileInput);
                } else {
                    alert('Please enter an API key for the selected provider, or use Browser TTS');
                    resetUI();
                    return;
                }
            } catch (error) {
                console.error('TTS Generation Error:', error);
                alert('Error generating speech. Check your API key and try again.');
                resetUI();
            }
        }

        async function generateBrowserTTS(script) {
            const utterance = new SpeechSynthesisUtterance(script);
            
            // Configure voice
            const voices = speechSynthesis.getVoices();
            const preferredVoice = voices.find(voice => 
                voice.name.includes('Google') || 
                voice.name.includes('Microsoft') ||
                voice.name.includes('Alex') ||
                voice.name.includes('Samantha')
            );
            
            if (preferredVoice) {
                utterance.voice = preferredVoice;
            }
            
            utterance.rate = 0.9;
            utterance.pitch = 1.2;
            utterance.volume = 0.8;

            utterance.onstart = () => {
                loading.classList.remove('active');
                startMouthAnimation();
            };

            utterance.onend = () => {
                resetUI();
            };

            utterance.onerror = () => {
                console.error('Speech synthesis error');
                resetUI();
            };

            currentAudio = utterance;
            speechSynthesis.speak(utterance);
        }

        async function generateKieAIVideo(script, imageBase64, key) {
            try {
                console.log('üîó Using backend server for API call...');
                
                // First, test if backend is reachable
                console.log('üîç Testing backend connectivity...');
                try {
                    console.log('üìç Testing URL: https://talking-pet-csx4.vercel.app/health');
                    
                    const healthResponse = await fetch('https://talking-pet-csx4.vercel.app/health', {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json'
                        },
                        mode: 'cors'
                    });
                    
                    console.log('üì° Health response status:', healthResponse.status, healthResponse.statusText);
                    console.log('üì° Health response headers:', [...healthResponse.headers.entries()]);
                    
                    if (healthResponse.ok) {
                        const healthData = await healthResponse.json();
                        console.log('‚úÖ Backend is reachable:', healthData);
                    } else {
                        console.warn('‚ö†Ô∏è Backend health check failed:', healthResponse.status, healthResponse.statusText);
                        const errorText = await healthResponse.text();
                        console.log('üì¶ Error response:', errorText);
                        throw new Error(`Backend health check failed: ${healthResponse.status}`);
                    }
                } catch (healthError) {
                    console.error('‚ùå Backend connectivity error details:');
                    console.error('  Error name:', healthError.name);
                    console.error('  Error message:', healthError.message);
                    console.error('  Error stack:', healthError.stack);
                    
                    // Try different approach
                    console.log('üîÑ Trying alternative health check...');
                    try {
                        const altResponse = await fetch('https://talking-pet-csx4.vercel.app/', {
                            method: 'GET',
                            mode: 'cors'
                        });
                        console.log('üì° Alternative check status:', altResponse.status);
                        if (altResponse.status === 404) {
                            console.log('‚úÖ Server is responding (404 is expected for GET /)');
                        } else {
                            throw new Error('Server not responding properly');
                        }
                    } catch (altError) {
                        console.error('‚ùå Alternative check failed:');
                        console.error('  Alt error name:', altError.name);
                        console.error('  Alt error message:', altError.message);
                        
                        // Try one more approach - simple GET to a known working endpoint
                        console.log('üîÑ Trying minimal request...');
                        try {
                            const response = await fetch('https://httpbin.org/json');
                            console.log('‚úÖ External fetch works (httpbin):', response.status);
                            throw new Error('Network works but cannot reach your backend. This might be a firewall or DNS issue with your Vercel domain.');
                        } catch (externalError) {
                            console.error('‚ùå External fetch also failed:', externalError.message);
                            throw new Error('Network connectivity issue detected. Please check your internet connection or try a different network/browser.');
                        }
                    }
                }
                
                const imageSizeMB = imageBase64.length / 1024 / 1024;
                console.log('üìè Image size:', imageSizeMB.toFixed(2), 'MB');
                
                // Try with very small test request first
                console.log('üß™ Testing with minimal request...');
                try {
                    const testResponse = await fetch('https://talking-pet-csx4.vercel.app/api/generate-video', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            script: "test",
                            apiKey: "test",
                            imageBase64: "test"
                        })
                    });
                    
                    console.log('üß™ Test request status:', testResponse.status);
                    if (testResponse.status === 400) {
                        console.log('‚úÖ Backend endpoint is working (expected 400 for test data)');
                    }
                } catch (testError) {
                    console.error('‚ùå Backend endpoint test failed:', testError.message);
                    throw new Error('Backend endpoint is not responding. Please try again later.');
                }
                
                // If we get here, try compression approach
                if (imageSizeMB > 0.3) {
                    console.log('üóúÔ∏è Image is large, attempting compression...');
                    try {
                        const compressedBase64 = await compressImage(imageBase64);
                        console.log('‚úÖ Image compressed from', imageBase64.length, 'to', compressedBase64.length, 'characters');
                        return await sendRequest(script, compressedBase64, key);
                    } catch (compressionError) {
                        console.warn('‚ö†Ô∏è Compression failed:', compressionError.message);
                        // Try with very aggressive compression
                        return await tryAggressiveCompression(script, imageBase64, key);
                    }
                } else {
                    return await sendRequest(script, imageBase64, key);
                }
                
            } catch (error) {
                console.error('üí• Video generation error:', error.message);
                throw error;
            }
        }

        async function tryAggressiveCompression(script, imageBase64, key) {
            console.log('üî• Trying aggressive compression...');
            
            try {
                const superCompressed = await compressImageAggressive(imageBase64);
                console.log('‚úÖ Super compressed from', imageBase64.length, 'to', superCompressed.length, 'characters');
                return await sendRequest(script, superCompressed, key);
            } catch (error) {
                throw new Error('Image is too large even with maximum compression. Please use a smaller image (under 100KB) or try the Browser TTS demo mode.');
            }
        }

        async function compressImageAggressive(base64String) {
            return new Promise((resolve, reject) => {
                console.log('üñºÔ∏è Starting aggressive compression...');
                
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Much smaller dimensions (max 400px)
                    const maxWidth = 400;
                    let { width, height } = img;
                    
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Very low quality compression (40%)
                    const compressedBase64 = canvas.toDataURL('image/jpeg', 0.4);
                    const base64Data = compressedBase64.split(',')[1];
                    
                    console.log('‚úÖ Aggressive compression complete. Original:', base64String.length, 'Compressed:', base64Data.length);
                    resolve(base64Data);
                };
                
                img.onerror = () => reject(new Error('Failed to load image for compression'));
                img.src = 'data:image/jpeg;base64,' + base64String;
            });
        }

        async function compressImage(base64String) {
            return new Promise((resolve, reject) => {
                console.log('üñºÔ∏è Starting image compression...');
                
                // Create an image element
                const img = new Image();
                img.onload = function() {
                    // Create canvas for compression
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Calculate new dimensions (max 800px width)
                    const maxWidth = 800;
                    let { width, height } = img;
                    
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Draw and compress
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to base64 with compression
                    const compressedBase64 = canvas.toDataURL('image/jpeg', 0.7); // 70% quality
                    const base64Data = compressedBase64.split(',')[1]; // Remove data:image/jpeg;base64,
                    
                    console.log('‚úÖ Compression complete. Original:', base64String.length, 'Compressed:', base64Data.length);
                    resolve(base64Data);
                };
                
                img.onerror = function() {
                    reject(new Error('Failed to load image for compression'));
                };
                
                // Load the image
                img.src = 'data:image/jpeg;base64,' + base64String;
            });
        }

        async function sendRequest(script, imageBase64, key) {
            // Try simple fetch first for smaller payloads
            const payload = {
                script: script,
                apiKey: key,
                imageBase64: imageBase64
            };
            
            const payloadSize = JSON.stringify(payload).length;
            console.log('üì¶ Payload size:', (payloadSize / 1024 / 1024).toFixed(2), 'MB');
            
            if (payloadSize < 5 * 1024 * 1024) { // Less than 5MB
                console.log('üöÄ Trying simple fetch request...');
                
                try {
                    const response = await fetch('https://talking-pet-csx4.vercel.app/api/generate-video', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });
                    
                    return await handleResponse(response);
                } catch (fetchError) {
                    console.error('‚ùå Fetch failed:', fetchError.message);
                    throw new Error(`Request failed: ${fetchError.message}. Try with a smaller image.`);
                }
            } else {
                throw new Error('Image is too large even after compression. Please use a smaller image (under 200KB).');
            }
        }

        async function handleResponse(response) {
            console.log('üì° Backend response:', response.status, response.statusText);
            
            if (!response.ok) {
                let errorData;
                try {
                    const responseText = await response.text();
                    console.log('üì¶ Error response:', responseText.substring(0, 200));
                    
                    try {
                        errorData = JSON.parse(responseText);
                    } catch {
                        errorData = { error: responseText };
                    }
                } catch {
                    errorData = { error: `HTTP ${response.status}` };
                }
                
                console.error('‚ùå Backend error:', errorData);
                
                if (response.status === 401) {
                    throw new Error('Invalid API key. Please check your Kie AI API key.');
                } else if (response.status === 403) {
                    throw new Error('Access denied. Check your Kie AI account credits.');
                } else if (response.status === 413) {
                    throw new Error('Request too large. Please use a smaller image.');
                } else if (response.status === 429) {
                    throw new Error('Rate limit exceeded. Please wait and try again.');
                } else if (response.status === 404) {
                    throw new Error('API endpoint not found.');
                } else {
                    throw new Error(errorData.error || `Server error: ${response.status}`);
                }
            }

            const result = await response.json();
            console.log('‚úÖ Backend success:', result);

            if (result.success && result.data) {
                const data = result.data;
                
                if (data.video_url || data.videoUrl || data.url) {
                    return {
                        success: true,
                        videoUrl: data.video_url || data.videoUrl || data.url
                    };
                } else if (data.task_id || data.taskId || data.id) {
                    console.log('‚è≥ Video is processing, polling for completion...');
                    return await pollForVideoCompletion(data.task_id || data.taskId || data.id, key);
                } else {
                    console.error('‚ùå Unexpected response format:', data);
                    throw new Error('Unexpected response format from Kie AI');
                }
            } else {
                throw new Error(result.error || 'Backend request failed');
            }
        }

        async function pollForVideoCompletion(taskId, key, maxAttempts = 60) { 
            console.log('‚è≥ Starting polling for task:', taskId);
            
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                try {
                    console.log(`üîÑ Polling attempt ${attempt + 1}/${maxAttempts} for task ${taskId}`);
                    
                    // Use the backend to poll status to avoid CORS issues
                    const response = await fetch('https://talking-pet-csx4.vercel.app/api/check-status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            taskId: taskId,
                            apiKey: key
                        })
                    });

                    if (!response.ok) {
                        console.error(`‚ùå Status check failed: ${response.status}`);
                        if (attempt === maxAttempts - 1) {
                            throw new Error('Status check failed after all attempts');
                        }
                        continue;
                    }

                    const result = await response.json();
                    console.log('üìä Status check result:', result);
                    
                    if (result.success && result.data) {
                        const data = result.data;
                        
                        if (data.status === 'completed' || data.status === 'success') {
                            if (data.video_url || data.videoUrl || data.url) {
                                console.log('‚úÖ Video completed:', data.video_url || data.videoUrl || data.url);
                                return {
                                    success: true,
                                    videoUrl: data.video_url || data.videoUrl || data.url
                                };
                            }
                        } else if (data.status === 'failed' || data.status === 'error') {
                            throw new Error(`Video generation failed: ${data.error || 'Unknown error'}`);
                        } else if (data.status === 'processing' || data.status === 'pending' || data.status === 'running') {
                            console.log('‚è≥ Still processing... waiting 3 seconds');
                        } else {
                            console.log('ü§î Unknown status:', data.status);
                        }
                    }
                    
                    // Wait 3 seconds before next poll
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    
                } catch (error) {
                    console.error(`‚ùå Polling error on attempt ${attempt + 1}:`, error.message);
                    if (attempt === maxAttempts - 1) {
                        throw new Error(`Polling failed after ${maxAttempts} attempts: ${error.message}`);
                    }
                    await new Promise(resolve => setTimeout(resolve, 3000));
                }
            }
            
            throw new Error('Video generation timed out after 3 minutes');
        }

        async function generateApiTTS(script, provider, key, fileInputElement) {
            console.log('üéØ generateApiTTS called with provider:', provider);
            
            // For Kie AI Veo 3, we need both image and script
            if (provider === 'kieai' || provider === 'veo3') {
                console.log('üé¨ Detected Kie AI provider (via backend), starting video generation...');
                
                // Get file directly from input element
                let fileToUse = null;
                
                // Try multiple ways to get the file
                if (fileInputElement && fileInputElement.files && fileInputElement.files.length > 0) {
                    fileToUse = fileInputElement.files[0];
                    console.log('üìÅ Got file from input element:', fileToUse.name);
                } else if (window.selectedFile) {
                    fileToUse = window.selectedFile;
                    console.log('üìÅ Got file from window.selectedFile:', fileToUse.name);
                } else if (typeof selectedFile !== 'undefined' && selectedFile) {
                    fileToUse = selectedFile;
                    console.log('üìÅ Got file from selectedFile:', fileToUse.name);
                } else {
                    console.error('‚ùå No file found in any location');
                    console.log('üîç fileInputElement:', !!fileInputElement);
                    console.log('üîç fileInputElement.files:', fileInputElement ? fileInputElement.files : 'null');
                    console.log('üîç fileInputElement.files.length:', fileInputElement && fileInputElement.files ? fileInputElement.files.length : 'null');
                    console.log('üîç window.selectedFile:', !!window.selectedFile);
                    console.log('üîç selectedFile defined:', typeof selectedFile !== 'undefined');
                    
                    // Let's also check what's in the FileList
                    if (fileInputElement && fileInputElement.files) {
                        console.log('üìã FileList contents:');
                        for (let i = 0; i < fileInputElement.files.length; i++) {
                            console.log(`  File ${i}:`, fileInputElement.files[i]);
                        }
                    }
                    
                    throw new Error('Please upload a pet image first');
                }
                
                console.log('üì∏ Using file:', fileToUse.name, 'Size:', fileToUse.size);
                
                // Convert image to base64
                console.log('üì∏ Converting image to base64...');
                const imageBase64 = await fileToBase64(fileToUse);
                console.log('‚úÖ Image converted, size:', imageBase64.length, 'characters');
                
                // Generate video with Kie AI
                const result = await generateKieAIVideo(script, imageBase64, key);
                
                if (result.success) {
                    // Show video result
                    displayVideoResult(result.videoUrl);
                } else {
                    throw new Error('Video generation failed');
                }
                return;
            } else if (provider === 'kieai-direct') {
                console.log('üé¨ Detected Kie AI Direct provider, starting direct API call...');
                
                // Get file
                let fileToUse = null;
                if (fileInputElement && fileInputElement.files && fileInputElement.files.length > 0) {
                    fileToUse = fileInputElement.files[0];
                    console.log('üìÅ Got file from input element:', fileToUse.name);
                } else {
                    throw new Error('Please upload a pet image first');
                }
                
                // Convert image to base64
                console.log('üì∏ Converting image to base64...');
                const imageBase64 = await fileToBase64(fileToUse);
                console.log('‚úÖ Image converted, size:', imageBase64.length, 'characters');
                
                // Generate video with direct Kie AI call
                const result = await generateKieAIVideoDirect(script, imageBase64, key);
                
                if (result.success) {
                    displayVideoResult(result.videoUrl);
                } else {
                    throw new Error('Video generation failed');
                }
                return;
            }

            console.log('üîä Using traditional TTS for provider:', provider);

            // Original TTS logic for other providers...
            const config = API_CONFIGS[provider];
            if (!config) {
                throw new Error('Unsupported provider');
            }

            let requestBody;
            let audioBlob;

            switch (provider) {
                case 'elevenlabs':
                    requestBody = {
                        text: script,
                        model_id: "eleven_monolingual_v1",
                        voice_settings: {
                            stability: 0.5,
                            similarity_boost: 0.75
                        }
                    };
                    
                    const elevenResponse = await fetch(`${config.url}/pNInz6obpgDQGcFmaJgB`, {
                        method: 'POST',
                        headers: config.headers(key),
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!elevenResponse.ok) {
                        throw new Error(`ElevenLabs API error: ${elevenResponse.status}`);
                    }
                    
                    audioBlob = await elevenResponse.blob();
                    break;

                case 'openai':
                    requestBody = {
                        model: "tts-1",
                        input: script,
                        voice: "alloy",
                        response_format: "mp3"
                    };
                    
                    const openaiResponse = await fetch(config.url, {
                        method: 'POST',
                        headers: config.headers(key),
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!openaiResponse.ok) {
                        throw new Error(`OpenAI API error: ${openaiResponse.status}`);
                    }
                    
                    audioBlob = await openaiResponse.blob();
                    break;

                case 'azure':
                    const ssml = `<speak version='1.0' xml:lang='en-US'>
                        <voice xml:lang='en-US' xml:gender='Female' name='en-US-JennyNeural'>
                            ${script}
                        </voice>
                    </speak>`;
                    
                    const azureResponse = await fetch(config.url, {
                        method: 'POST',
                        headers: config.headers(key),
                        body: ssml
                    });
                    
                    if (!azureResponse.ok) {
                        throw new Error(`Azure API error: ${azureResponse.status}`);
                    }
                    
                    audioBlob = await azureResponse.blob();
                    break;
            }

            // Play the audio
            const audioUrl = URL.createObjectURL(audioBlob);
            const audio = new Audio(audioUrl);
            
            audio.onloadstart = () => {
                loading.classList.remove('active');
                startMouthAnimation();
            };
            
            audio.onended = () => {
                resetUI();
                URL.revokeObjectURL(audioUrl);
            };
            
            audio.onerror = () => {
                throw new Error('Audio playback error');
            };
            
            currentAudio = audio;
            audio.play();
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64 = reader.result.split(',')[1]; // Remove data:image/jpeg;base64, prefix
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function displayVideoResult(videoUrl) {
            loading.classList.remove('active');
            
            // Create video element
            const videoContainer = document.createElement('div');
            videoContainer.style.cssText = `
                margin-top: 30px;
                text-align: center;
                padding: 20px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 15px;
            `;
            
            videoContainer.innerHTML = `
                <h3 style="color: #333; margin-bottom: 20px;">üéâ Your Talking Pet Video is Ready!</h3>
                <video controls style="max-width: 100%; border-radius: 10px; box-shadow: 0 10px 20px rgba(0,0,0,0.2);">
                    <source src="${videoUrl}" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                <br><br>
                <button onclick="window.open('${videoUrl}', '_blank')" style="margin: 5px;">üì• Download Video</button>
                <button onclick="shareVideo('${videoUrl}')" style="margin: 5px;">üì± Share Video</button>
            `;
            
            // Remove any existing video results
            const existingResult = document.querySelector('.video-result-container');
            if (existingResult) existingResult.remove();
            
            videoContainer.className = 'video-result-container';
            document.querySelector('.container').appendChild(videoContainer);
            
            // Reset UI
            generateBtn.style.display = 'block';
            stopBtn.style.display = 'none';
        }

        async function generateKieAIVideoDirect(script, imageBase64, key) {
            try {
                console.log('üîó Using direct Kie AI API call (bypassing backend)...');
                
                // Compress image first
                const imageSizeMB = imageBase64.length / 1024 / 1024;
                console.log('üìè Original image size:', imageSizeMB.toFixed(2), 'MB');
                
                let finalImageBase64 = imageBase64;
                if (imageSizeMB > 0.1) { // Very aggressive limit
                    console.log('üóúÔ∏è Compressing image for direct API call...');
                    finalImageBase64 = await compressImageUltra(imageBase64);
                    console.log('‚úÖ Ultra compressed to:', (finalImageBase64.length / 1024 / 1024).toFixed(2), 'MB');
                }
                
                // Check final size
                const finalSizeMB = finalImageBase64.length / 1024 / 1024;
                if (finalSizeMB > 0.5) {
                    throw new Error(`Image still too large: ${finalSizeMB.toFixed(2)}MB. Please use an image under 50KB original size.`);
                }
                
                // Use the correct Kie AI API format based on their documentation
                const requestBody = {
                    text: script, // Kie AI might use 'text' instead of 'prompt'
                    image_data: finalImageBase64, // Try different field name
                    duration_seconds: 8,
                    include_audio: true,
                    model_type: 'veo3'
                };

                console.log('üöÄ Calling Kie AI API directly...');
                console.log('  üìç URL: https://api.kie.ai/v1/video/generate');
                console.log('  üìù Text length:', script.length);
                console.log('  üñºÔ∏è Image size:', finalImageBase64.length, 'characters');
                console.log('  üì¶ Request body keys:', Object.keys(requestBody));
                
                // Try direct call to Kie AI with proper format
                const response = await fetch('https://api.kie.ai/v1/video/generate', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log('üì° Kie AI direct response:', response.status, response.statusText);

                // Get response details
                const responseText = await response.text();
                console.log('üì¶ Response text:', responseText.substring(0, 500));

                if (!response.ok) {
                    console.error('‚ùå Kie AI direct error:', responseText);
                    
                    if (response.status === 401) {
                        throw new Error('Invalid API key. Please check your Kie AI API key.');
                    } else if (response.status === 403) {
                        throw new Error('Access denied. Check your Kie AI account credits.');
                    } else if (response.status === 400) {
                        throw new Error(`Bad request: ${responseText}. The API format might have changed.`);
                    } else if (response.status === 429) {
                        throw new Error('Rate limit exceeded. Please wait and try again.');
                    } else {
                        throw new Error(`Kie AI API error: ${response.status} - ${responseText}`);
                    }
                }

                let result;
                try {
                    result = JSON.parse(responseText);
                    console.log('‚úÖ Kie AI direct success:', result);
                } catch (parseError) {
                    throw new Error(`Invalid JSON response: ${responseText}`);
                }

                if (result.video_url || result.videoUrl || result.url) {
                    return {
                        success: true,
                        videoUrl: result.video_url || result.videoUrl || result.url
                    };
                } else if (result.task_id || result.taskId || result.id) {
                    console.log('‚è≥ Video is processing, polling for completion...');
                    return await pollForVideoCompletionDirect(result.task_id || result.taskId || result.id, key);
                } else {
                    console.error('‚ùå Unexpected response format:', result);
                    throw new Error('Unexpected response format from Kie AI');
                }
                
            } catch (error) {
                console.error('üí• Direct Kie AI error:', error.message);
                throw error;
            }
        }

        async function compressImageUltra(base64String) {
            return new Promise((resolve, reject) => {
                console.log('üñºÔ∏è Starting ultra compression...');
                
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Ultra small dimensions (max 200px)
                    const maxWidth = 200;
                    let { width, height } = img;
                    
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Ultra low quality compression (20%)
                    const compressedBase64 = canvas.toDataURL('image/jpeg', 0.2);
                    const base64Data = compressedBase64.split(',')[1];
                    
                    console.log('‚úÖ Ultra compression complete. Original:', base64String.length, 'Compressed:', base64Data.length);
                    resolve(base64Data);
                };
                
                img.onerror = () => reject(new Error('Failed to load image for compression'));
                img.src = 'data:image/jpeg;base64,' + base64String;
            });
        }

        async function pollForVideoCompletionDirect(taskId, key, maxAttempts = 60) { 
            console.log('‚è≥ Starting direct polling for task:', taskId);
            
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                try {
                    console.log(`üîÑ Direct polling attempt ${attempt + 1}/${maxAttempts} for task ${taskId}`);
                    
                    const response = await fetch(`https://api.kie.ai/v1/video/status/${taskId}`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${key}`,
                            'Accept': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        console.error(`‚ùå Direct status check failed: ${response.status}`);
                        if (attempt === maxAttempts - 1) {
                            throw new Error('Status check failed after all attempts');
                        }
                        continue;
                    }

                    const result = await response.json();
                    console.log('üìä Direct status check result:', result);
                    
                    if (result.status === 'completed' || result.status === 'success') {
                        if (result.video_url || result.videoUrl || result.url) {
                            console.log('‚úÖ Direct video completed:', result.video_url || result.videoUrl || result.url);
                            return {
                                success: true,
                                videoUrl: result.video_url || result.videoUrl || result.url
                            };
                        }
                    } else if (result.status === 'failed' || result.status === 'error') {
                        throw new Error(`Video generation failed: ${result.error || 'Unknown error'}`);
                    } else if (result.status === 'processing' || result.status === 'pending' || result.status === 'running') {
                        console.log('‚è≥ Still processing... waiting 3 seconds');
                    } else {
                        console.log('ü§î Unknown status:', result.status);
                    }
                    
                    // Wait 3 seconds before next poll
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    
                } catch (error) {
                    console.error(`‚ùå Direct polling error on attempt ${attempt + 1}:`, error.message);
                    if (attempt === maxAttempts - 1) {
                        throw new Error(`Direct polling failed after ${maxAttempts} attempts: ${error.message}`);
                    }
                    await new Promise(resolve => setTimeout(resolve, 3000));
                }
            }
            
            throw new Error('Video generation timed out after 3 minutes');
        }

        function resetUI() {
            stopMouthAnimation();
            speechBubble.classList.remove('active');
            loading.classList.remove('active');
            generateBtn.style.display = 'block';
            stopBtn.style.display = 'none';
        }

        function startMouthAnimation() {
            const mouthElement = animationOverlay.querySelector('.mouth-animation');
            if (mouthElement) {
                // Random mouth movement animation
                animationInterval = setInterval(() => {
                    mouthElement.classList.add('talking');
                    setTimeout(() => {
                        mouthElement.classList.remove('talking');
                    }, 100 + Math.random() * 200);
                }, 150 + Math.random() * 100);
            }
        }

        function stopMouthAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            const mouthElement = animationOverlay.querySelector('.mouth-animation');
            if (mouthElement) {
                mouthElement.classList.remove('talking');
            }
        }

        function stopTalking() {
            if (currentAudio) {
                if (currentAudio instanceof Audio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                } else {
                    speechSynthesis.cancel();
                }
                currentAudio = null;
            }
            resetUI();
        }

        // Load voices when available
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = () => {
                // Voices loaded
            };
        }

        // PWA Installation
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing on mobile
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            // Show install button
            showInstallButton();
        });

        function showInstallButton() {
            const installBtn = document.createElement('button');
            installBtn.textContent = 'üì± Install App';
            installBtn.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: linear-gradient(45deg, #667eea, #764ba2);
                color: white;
                border: none;
                padding: 12px 20px;
                border-radius: 25px;
                cursor: pointer;
                font-weight: bold;
                z-index: 1000;
                box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            `;
            
            installBtn.addEventListener('click', async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    if (outcome === 'accepted') {
                        installBtn.remove();
                    }
                    deferredPrompt = null;
                }
            });
            
            document.body.appendChild(installBtn);
        }

        // Add some sample scripts
        const sampleScripts = [
            "Hello! I'm a good boy and I love treats!",
            "Woof woof! Let's go for a walk!",
            "Meow! I demand more tuna right now!",
            "I love you so much, human!",
            "Can we play fetch now? Please?",
            "I'm the cutest pet in the world!"
        ];

        // Add sample script functionality
        scriptInput.addEventListener('focus', () => {
            if (!scriptInput.value) {
                const randomScript = sampleScripts[Math.floor(Math.random() * sampleScripts.length)];
                scriptInput.placeholder = `Try: "${randomScript}"`;
            }
        });

        // Add enter key support
        scriptInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                generateBtn.click();
            }
        });
    </script>
</body>
</html>
